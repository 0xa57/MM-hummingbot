'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _tslib = require('../_tslib-bcbe0269.js');
var core = require('@emotion/core');
var React = require('react');
var React__default = _interopDefault(React);
var classnames = _interopDefault(require('classnames'));
require('../fonts/fonts.js');
var base$1 = require('../base-1dde5d6e.js');
require('../mono-f4fb9dce.js');
var colors = require('../colors/colors.js');
var assertUnreachable = require('../assertUnreachable-18645656.js');
require('../colors/utils/findPaletteByColor.js');
var getOffsetInPalette = require('../colors/utils/getOffsetInPalette.js');
var tinycolor = _interopDefault(require('tinycolor2'));
require('../SpaceKitProvider/index.js');
var LoadingSpinner = require('../Loaders/LoadingSpinner.js');

/**
 * Save a default color so we can check if we used the default or not. The
 * default color has a few special properties.
 */
var defaultColor = colors.colors.silver.light;
/**
 * Get the button's text color
 */
function getTextColor(_a) {
    var color = _a.color, feel = _a.feel, theme = _a.theme, mode = _a.mode;
    // Text color will always be the same for secondary buttons
    if (color === colors.colors.white) {
        return colors.colors.grey.darker;
    }
    switch (feel) {
        case "raised":
            // Set the base (meaning no pseudo-selectors) text color for raised
            // buttons. Otherwise return `undefined` to not change the color.
            //
            // We have some special logic for the raised color; set the text color to
            // be what is most readable between white and the default text color and
            // the _hover_ color's background. This is overrideable by the user, but
            // it shouldn't need to be.
            return !mode
                ? tinycolor
                    .mostReadable(getHoverBackgroundColor({ color: color, feel: feel, theme: theme }), [colors.colors.white, colors.colors.grey.darker], {
                    level: "AA",
                    size: "small",
                })
                    .toString()
                : undefined;
        case "flat":
            if (color === defaultColor) {
                return theme === "dark" ? colors.colors.grey.light : colors.colors.grey.darker;
            }
            // We have a custom color and we're in dark mode, lighten the base and
            // focused colors 1 shade.
            if (theme === "dark" && (!mode || mode === ":focus")) {
                return getOffsetInPalette.getOffsetInPalette(1, "lighter", color);
            }
            return color;
        /* istanbul ignore next */
        default:
            throw assertUnreachable.assertUnreachable(feel);
    }
}
/**
 * Get the button's height
 */
function getHeight(_a) {
    var size = _a.size;
    switch (size) {
        case "small":
            return 28;
        case "default":
            return 36;
        case "large":
            return 42;
        /* istanbul ignore next */
        default:
            throw assertUnreachable.assertUnreachable(size);
    }
}
/**
 * Get the hover background color
 */
function getHoverBackgroundColor(_a) {
    var color = _a.color, feel = _a.feel, theme = _a.theme;
    if (color === colors.colors.white) {
        // Special case for secondary buttons
        return colors.colors.silver.light;
    }
    switch (feel) {
        case "flat":
            // Hardcode if we're using the default color (special case), otherwise get
            // the next lightest color.
            if (color === defaultColor) {
                return theme === "light" ? colors.colors.silver.light : colors.colors.grey.dark;
            }
            return getOffsetInPalette.getOffsetInPalette(Infinity, "lighter", color);
        case "raised":
            // One shade darker
            return getOffsetInPalette.getOffsetInPalette(1, "darker", color);
        /* istanbul ignore next */
        default:
            throw assertUnreachable.assertUnreachable(feel);
    }
}
/**
 * Style system for Space Kit buttons
 *
 * This is intended to be used as an abstraction for your project's style guide.
 *
 * @see https://zpl.io/amdN6Pr
 */
var Button = React__default.forwardRef(function (_a, ref) {
    var _b = _a.as, as = _b === void 0 ? React__default.createElement("button", null) : _b, children = _a.children, _c = _a.color, color = _c === void 0 ? defaultColor : _c, _d = _a.disabled, disabledProps = _d === void 0 ? false : _d, variant = _a.variant, endIcon = _a.endIcon, _e = _a.feel, feel = _e === void 0 ? "raised" : _e, iconProp = _a.icon, loading = _a.loading, _f = _a.size, size = _f === void 0 ? "default" : _f, _g = _a.theme, theme = _g === void 0 ? "light" : _g, otherProps = _tslib.__rest(_a, ["as", "children", "color", "disabled", "variant", "endIcon", "feel", "icon", "loading", "size", "theme"]);
    return (React__default.createElement(core.ClassNames, null, function (_a) {
        var cx = _a.cx, css = _a.css;
        /**
         * If the button is in a `loading` state, then always treat it as
         * disabled. Otherwise, try to use `as.props`. Finally, use `props`
         */
        var disabled = loading ||
            (as.props.disabled != null ? as.props.disabled : disabledProps);
        var icon = loading ? (React__default.createElement(LoadingSpinner.LoadingSpinner, { size: "2xsmall", theme: theme === "light" ? "grayscale" : "dark" })) : (iconProp);
        /**
         * Icon size in pixels
         *
         * This is stored so we can use the same value for `height` and `width`
         */
        var iconSize = size === "small" ? 12 : size === "large" ? 24 : 16;
        var iconOnly = !children;
        if (variant === "fab") {
            if (!icon) {
                throw new TypeError("FAB buttons are required to have an `icon`");
            }
            else if (children) {
                throw new TypeError("FAB buttons cannot have children, only an `icon`");
            }
        }
        var propsToPass = _tslib.__assign(_tslib.__assign({}, otherProps), { ref: ref, className: classnames(
            // I couldn't figure out how to get TypeScript to recognize that
            // `className` can be in `otherProps`.
            "className" in otherProps && otherProps.className, cx(css([
                _tslib.__assign(_tslib.__assign(_tslib.__assign(_tslib.__assign({ 
                    // We need to also set the `:hover` on `:disabled` so it has a
                    // higher specificity than any `:hover` classes passed in. This
                    // also means that both of these need to be overriden if we want
                    // to use a custom disabled color.
                    "&[disabled], &[disabled]:hover": {
                        backgroundColor: feel === "flat"
                            ? "transparent"
                            : theme === "light"
                                ? colors.colors.silver.light
                                : colors.colors.grey.dark,
                        boxShadow: "none",
                        color: feel === "flat" && theme === "dark"
                            ? colors.colors.grey.dark
                            : colors.colors.grey.light,
                    }, backgroundColor: color === colors.colors.white
                        ? colors.colors.white
                        : feel === "raised"
                            ? color
                            : "transparent", borderRadius: variant === "fab" ? "100%" : 4, borderWidth: 0 }, (feel !== "flat" && {
                    boxShadow: theme === "light"
                        ? "0 1px 4px 0 rgba(18, 21, 26, 0.04), inset 0 0 0 1px rgba(18, 21, 26, 0.2), inset 0 -1px 0 0 rgba(18, 21, 26, 0.05)"
                        : "0 0 0 1px rgba(18, 21, 26, 0.2), 0 1px 4px 0 rgba(18, 21, 26, 0.08), 0 1px 0 0 rgba(18, 21, 26, 0.05)",
                })), { color: getTextColor({ color: color, feel: feel, theme: theme }), cursor: loading || disabled ? "default" : "pointer", 
                    // Vertically center children
                    display: "inline-flex", alignItems: "center", justifyContent: "center", height: getHeight({ size: size }), minWidth: iconOnly
                        ? size === "small"
                            ? 28
                            : size === "large"
                                ? 42
                                : 36
                        : size === "small"
                            ? 76
                            : size === "large"
                                ? 112
                                : 100, 
                    // We have to set the Y padding because browsers (at least Chrome) has
                    // a non-symmetrical vertical padding applied by default.
                    padding: "0 " + (iconOnly ? 0 : 12) + "px" }), (size === "small"
                    ? base$1.small
                    : size === "large"
                        ? base$1.large
                        : base$1.base)), { fontWeight: 600, 
                    // Disable the outline because we're setting a custom `:active` style
                    outline: 0, textDecoration: "none", whiteSpace: "nowrap" }),
                !disabled && {
                    ":hover, &[data-force-hover-state]": _tslib.__assign({ backgroundColor: getHoverBackgroundColor({
                            color: color,
                            feel: feel,
                            theme: theme,
                        }), color: getTextColor({ color: color, feel: feel, theme: theme, mode: ":hover" }) }, (feel !== "flat" && {
                        // The `box-shadow` property is copied directly from Zeplin
                        boxShadow: theme === "light"
                            ? "0 5px 10px 0 rgba(18, 21, 26, 0.08), inset 0 0 0 1px rgba(18, 21, 26, 0.2), inset 0 -1px 0 0 rgba(18, 21, 26, 0.05)"
                            : "0 0 0 1px rgba(18, 21, 26, 0.2), 0 5px 10px 0 rgba(18, 21, 26, 0.12), 0 1px 0 0 rgba(18, 21, 26, 0.05)",
                    })),
                    ":focus, &[data-force-focus-state]": _tslib.__assign(_tslib.__assign({}, (feel === "flat" && {
                        backgroundColor: theme === "light" ? colors.colors.white : "#000",
                        color: theme === "light"
                            ? colors.colors.blue.base
                            : colors.colors.blue.light,
                    })), { 
                        // The `box-shadow` property is copied directly from Zeplin for the
                        // light theme. For the dark theme we use a variant of the color to
                        // make the borders sharp.
                        boxShadow: "0 1px 4px 0 rgba(18, 21, 26, 0.08), 0 0 0 2px " + (theme === "light" ||
                            color === defaultColor ||
                            color === colors.colors.white
                            ? "#bbdbff"
                            : getOffsetInPalette.getOffsetInPalette(Infinity, "lighter", color)) + ", inset 0 0 0 1px " + (color === defaultColor || color === colors.colors.white
                            ? "#2075d6"
                            : getOffsetInPalette.getOffsetInPalette(1, "darker", color)) + ", inset 0 -1px 0 0 rgba(18, 21, 26, 0.05)" }),
                    "&:active, &[data-force-active-state], &[aria-expanded=true]": _tslib.__assign(_tslib.__assign({}, (getTextColor({
                        color: color,
                        feel: feel,
                        theme: theme,
                        mode: ":hover",
                    }) && {
                        color: getTextColor({
                            color: color,
                            feel: feel,
                            theme: theme,
                            mode: ":active",
                        }),
                    })), { backgroundColor: color === colors.colors.white
                            ? colors.colors.white
                            : feel === "raised"
                                ? color
                                : color === defaultColor
                                    ? theme === "dark"
                                        ? colors.colors.grey.darker
                                        : colors.colors.silver.base
                                    : getOffsetInPalette.getOffsetInPalette(2, "lighter", color), 
                        // The `box-shadow` properties are copied directly from Zeplin
                        boxShadow: feel !== "flat"
                            ? theme === "light"
                                ? "inset 0 0 0 1px rgba(18, 21, 26, 0.2), inset 0 -1px 0 0 rgba(18, 21, 26, 0.05), inset 0 2px 2px 0 rgba(18, 21, 26, 0.12)"
                                : "0 0 0 1px rgba(18, 21, 26, 0.2), 0 1px 4px 0 rgba(18, 21, 26, 0.08), 0 -1px 0 0 rgba(18, 21, 26, 0.16), inset 0 1px 2px 0 rgba(18, 21, 26, 0.42)"
                            : "none", outline: "0" }),
                },
            ]))), disabled: disabled, onClick: function (event) {
                if (disabled)
                    return event.preventDefault();
                if (otherProps.onClick) {
                    otherProps.onClick(event);
                }
                if (as.props.onClick) {
                    as.props.onClick(Event);
                }
                // Remove the focus
                event.currentTarget.blur();
            }, children: (React__default.createElement(React__default.Fragment, null,
                icon && (React__default.createElement("span", { className: cx(css({
                        alignItems: "center",
                        // This needs to be `inline-flex` and not the default of
                        // `inline-block` to vertically center the icon automatically
                        display: "inline-flex",
                        height: iconSize,
                        justifyContent: "center",
                        // The `4px` will be on the right to separate the icon from the text
                        margin: iconOnly ? 0 : "0 4px 0",
                        width: iconSize,
                    })) }, icon)),
                children,
                endIcon && !loading && (React__default.createElement("span", { className: cx(css({
                        alignItems: "center",
                        // This needs to be `inline-flex` and not the default of
                        // `inline-block` to vertically center the icon automatically
                        display: "inline-flex",
                        height: iconSize,
                        justifyContent: "center",
                        // The `4px` will be on the right to separate the icon from the text
                        margin: iconOnly ? 0 : "0 0 0 4px",
                        width: iconSize,
                    })) }, endIcon)))) });
        return React__default.cloneElement(as, _tslib.__assign(_tslib.__assign({}, propsToPass), { className: classnames(propsToPass.className, as.props.className, 
            // If the parent component is using emotion with the jsx pragma, we
            // have to get fancy and intercept the styles to use with the
            // `ClassNames` wrapper.
            as.props.css ? css(as.props.css.styles) : null) }));
    }));
});

exports.Button = Button;
//# sourceMappingURL=Button.js.map
